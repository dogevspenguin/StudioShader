// ---- Created with 3Dmigoto v1.3.16
// FINAL FIX: Depth Occlusion + WIND COORDINATE FIX + MOON REMOVAL + SUNSET COLORS

cbuffer CB0 : register(b0)
{
    struct
    {
        row_major float4x4 ViewProjection[2];
        float4 ViewRight;
        float4 ViewUp;
        float4 ViewDir;
        float3 CameraPosition[2];
        float3 AmbientColor;
        float4 SkyAmbient;
        float3 Lamp0Color;
        float3 Lamp0Dir;
        float3 Lamp1Color;
        float4 FogParams;
        float4 FogColor_GlobalForceFieldTime;
        float4 Exposure_DoFDistance;
        float4 LightConfig0;
        float4 LightConfig1;
        float4 LightConfig2;
        float4 LightConfig3;
        float4 ShadowMatrix0;
        float4 ShadowMatrix1;
        float4 ShadowMatrix2;
        float4 RefractionBias_FadeDistance_GlowFactor_Free;
        float4 TextureData_ShadowInfo;
        float4 SkyGradientTop_EnvDiffuse;
        float4 SkyGradientBottom_EnvSpec;
        float4 AmbientColorNoIBL_CubeBlend;
        float4 SkyAmbientNoIBL;
        float4 AmbientCube[12];
        float4 CascadeSphere0;
        float4 CascadeSphere1;
        float4 CascadeSphere2;
        float4 CascadeSphere3;
        float2 invViewportWH;
        float2 viewportScale;
        float debugAuthLodMode;
        float padding;
        float hqDist;
        float localLightDist;
        float sunDist;
        float hybridLerpSlope;
        float evsmPosExp;
        float evsmNegExp;
        float globalShadow;
        float shadowBias;
        float packedAlphaRef;
        float debugFlags;
        row_major float4x4 FroxelTransform;
        float4 SkyboxRotation0;
        float4 SkyboxRotation1;
        float4 SkyboxRotation2;
    } CB0 : packoffset(c0);
}

cbuffer CB4 : register(b4)
{
    struct
    {
        float4 FoV;
        float2 shearOffset;
        float2 pad;
    } CB4 : packoffset(c0);
}

cbuffer CB5 : register(b5)
{
    struct
    {
        float4 DirDist;
        // This contains the wind offset
        float4 LightColorSize;
        float4 CoverDensityQuality;
        float4 Color;
        float4 DetailScale;
    } CB5 : packoffset(c0);
}
// Define the special parameter texture on slot 125
// Change StructuredBuffer to just Buffer
// Change Buffer<float4> to Buffer<float>
Buffer<float> TimeBuffer : register(t120);
SamplerState CloudsSampler_s : register(s0);
Texture2D<float4> CloudsTexture : register(t0);
SamplerState sampler3_s : register(s3);
Texture2D<float> GlobalDepth : register(t100);
Texture2D<float4> SkyColor : register(t99);
// --- PROCEDURAL NOISE ---
static const float CUMULUS_BOT = (6000);
static const float CUMULUS_TOP = (12000 + 3000);
static const float CIRRUS_BOT = 8000.0 * 3;
static const float CIRRUS_TOP = 10000.0 * 3;

float hash(float2 p) {
    p = frac(p * float2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return frac(p.x * p.y);
}

float noise(float2 p) {
    float2 i = floor(p);
    float2 f = frac(p);
    f = f * f * (3.0 - 2.0 * f);
    float res = lerp(lerp(hash(i), hash(i + float2(1.0, 0.0)), f.x),
                     lerp(hash(i + float2(0.0, 1.0)), hash(i + float2(1.0, 1.0)), f.x), f.y);
    return res;
}

float fbm(float2 p) {
    float f = 0.0;
    f += 0.5000 * noise(p);
    p = p * 2.02;
    f += 0.2500 * noise(p);
    p = p * 2.03;
    f += 0.1250 * noise(p);
    return f;
}

// 3D Noise wrappers
float2 hash2(float n) {
    return frac(sin(float2(n, n + 1.0)) * float2(43758.5453, 22578.1459));
}

float noise3D(float3 p) {
    float iz = floor(p.z);
    float fz = frac(p.z);
    float z_blend = fz * fz * (3.0 - 2.0 * fz);
    float2 offset1 = hash2(iz) * 300.0;
    float2 offset2 = hash2(iz + 1.0) * 300.0;
    float n1 = noise(p.xy + offset1);
    float n2 = noise(p.xy + offset2);
    return lerp(n1, n2, z_blend);
}

float fbm3d(float3 p) {
    float f = 0.0;
    f += 0.5000 * noise3D(p);
    p = p * 2.02;
    f += 0.2500 * noise3D(p);
    p = p * 2.03;
    f += 0.1250 * noise3D(p);
    return f;
}

float PhaseDualLobe(float cosTheta, float g1, float g2, float w) {
    float p1 = (1.0 - g1 * g1) / pow(max(0.001, 1.0 + g1 * g1 - 2.0 * g1 * cosTheta), 1.5);
    float p2 = (1.0 - g2 * g2) / pow(max(0.001, 1.0 + g2 * g2 - 2.0 * g2 * cosTheta), 1.5);
    return (w * p1 + (1.0 - w) * p2);
}

float2 IntersectCloudLayer(float3 ro, float3 rd, float hBot, float hTop) {
    float signY = (rd.y >= 0.0) ? 1.0 : -1.0;
    float rayY = abs(rd.y) < 0.0001 ? 0.0001 * signY : rd.y;
    float tBot = (hBot - ro.y) / rayY;
    float tTop = (hTop - ro.y) / rayY;
    float tMin = min(tBot, tTop);
    float tMax = max(tBot, tTop);

    if (tMax < 0.0) return float2(-1, -1);
    tMin = max(0.0, tMin);
    return float2(tMin, tMax);
}

// UPDATED: Now accepts 'windUV' to offset the noise coordinates directly
float GetDensity(float3 pos, float cloudBottom, float cloudThickness, float noiseScale, float3 windUV) {
    // Apply wind offset directly to the UVs.
    // 1.0 in 'windUV' = 1 Full Cycle of noise, matching the game's texture scroll behavior.
 
    float2 uv = (pos.xz) * noiseScale + windUV.xz;

    float noiseVal = fbm(uv);
    float heightRatio = (pos.y - cloudBottom) / (cloudThickness);
    float heightMask = 4.0 * heightRatio * (1.0 - heightRatio);
    heightMask = saturate(heightMask);
    // Also apply wind to the 3D erosion noise so the details move with the cloud
    float skib = fbm3d(pos / 1000) * 0.5;
    return noiseVal * (heightMask - skib * heightMask);
}

float GetDensityC(float3 pos, float cloudBottom, float cloudThickness, float2 noiseScale, float3 windUV) {
    // Apply wind offset directly to the UVs.
    // 1.0 in 'windUV' = 1 Full Cycle of noise, matching the game's texture scroll behavior.
    float2 uv = pos.xz * noiseScale + windUV.xz;

    float noiseVal = fbm(uv);
    float heightRatio = (pos.y - cloudBottom) / (cloudThickness);
    float heightMask = 4.0 * heightRatio * (1.0 - heightRatio);
    heightMask = saturate(heightMask);
    // Also apply wind to the 3D erosion noise so the details move with the cloud
    float skib = fbm3d(pos / 1000 + windUV) * 0.5;
    return noiseVal * (heightMask - skib * heightMask);
}

float GetDensity2(float3 pos, float cloudBottom, float cloudThickness, float noiseScale, float3 windUV) {
    float density = 0;
    if (pos.y >= CUMULUS_BOT && pos.y <= CUMULUS_TOP) {
        density = density + GetDensity(pos, CUMULUS_BOT, CUMULUS_TOP - CUMULUS_BOT, noiseScale, windUV);
    }
    if (pos.y >= CIRRUS_BOT && pos.y <= CIRRUS_TOP) {
        density = density + GetDensityC(pos, CIRRUS_BOT, 2000, noiseScale * float2(10, 1), windUV) * 0;
    }
    return density;
}
float InterleavedGradientNoise(float2 uv) {
    float3 magic = float3(0.06711056, 0.00583715, 52.9829189);
    return frac(magic.z * frac(dot(uv, magic.xy)));
}
void main(
    float4 v0 : SV_Position0,
    out float4 o0 : SV_Target0,
    out float oDepth : SV_Depth)
{
    float DEPTH_CONTROL = 0.1;
     float2 screenUV = v0.xy * CB0.invViewportWH;
    // UPDATED: Match the 0.1 constant from user data
    int3 pixelCoord = int3(v0.xy, 0);
    float Bob = TimeBuffer.Load(0); 
    float hwDepth = GlobalDepth.Sample(CloudsSampler_s, screenUV*1).x;//GlobalDepth.Load(pixelCoord).r;
    // Uncomment this to check if depth is loading.
// If screen is BLACK: Texture is empty (Unbind failed).
// If screen is WHITE/GREY gradient: Texture is VALID.
    // Linearize Depth: Distance = 0.1 / Depth
    float sceneDepth = DEPTH_CONTROL / (hwDepth+0.0000000001);
    
    // Reconstruct Ray
    float4 r0;
    float3 r1;
    r0.xy = float2(0.5, 0.5) * v0.xy;
    r0.xy = r0.xy / CB0.viewportScale.xy;
    r0.zw = r0.xy * CB4.FoV.xy + float2(-1, -1);
    r0.zw = CB4.FoV.zw * r0.zw + CB4.shearOffset.xy;
    r1.xyz = CB0.ViewUp.xyz * r0.www;
    r1.xyz = r0.zzz * CB0.ViewRight.xyz + -r1.xyz;
    r1.xyz = -CB0.ViewDir.xyz + r1.xyz;
    float3 rayDir = normalize(r1);
    float3 camPos = CB0.CameraPosition[0].xyz;
    // Config
    float3 viewForward = normalize(CB0.ViewDir.xyz);
    // Use abs() to handle coordinate system direction differences safely
    float viewCosTheta = abs(dot(rayDir, viewForward));
    float cloudBottom = 6000; //1500;
    float cloudTop = (12000 + 3000);
    float cloudThickness = cloudTop - cloudBottom;
    float4 cloudColor = float4(1.0, 1.0, 1.0, 1.0);
    float coverage = CB5.CoverDensityQuality.x > 0.0 ? CB5.CoverDensityQuality.x : 0.45;
    float2 intersection = IntersectCloudLayer(camPos, rayDir, 6000, (12000 + 3000));

    // 1. Get distance to nearest boundary (top or bottom)
    float dist = min(max(camPos.y - (cloudTop + 200), 0), min(cloudBottom - 200, 0 - camPos.y));
    // 2. Define the fade size (e.g. 50 studs) and normalize to 0-1
    // 2. Define the fade size (e.g. 50 studs) and normalize to 0-1
    float fadeFactor = saturate(dist / 400);

    // [CHANGED] REMOVED "Screen Door" Dithering. 
    // Instead of killing pixels randomly here, we will multiply the Alpha at the end.
    // intersection.x *= step(hash(v0.xy), fadeFactor); <--- DELETED

    float tNear = intersection.x;
    
    // [CHANGED] Use IGN for smoother ray offsets (Volume Blur effect)
    // We use a separate multiplier for the offset to keep the pattern tight
    float ditherVal = InterleavedGradientNoise(v0.xy);
    
    float tFar = intersection.y + 500 * ditherVal;

    float3 finalColor = float3(0, 0, 0);
    float finalAlpha = 0.0;
    float tcul = 0;

    // Track depth of the cloud
    float outputLinearDepth = sceneDepth;
    bool depthCaptured = false;
    float3 sunDir;
    if (tFar > tNear)
    {
        int steps = 300;
        float maxDist = 400000.0;
        float t = tNear;

        float marchStep = 500.0; // + (t * 0.005);
        t += marchStep * ditherVal;

        float3 accumulatedColor = float3(0, 0, 0);
        float transmittance = 1.0;

        float noiseScale = 0.0001;
        float3 windUV = Bob/100;//CB5.DirDist.xyz;

        sunDir = -normalize(CB0.Lamp0Dir.xyz);
        float3 sunColor = CB0.Lamp0Color.xyz;
        
        // --- MOON DETECTION LOGIC ---
        float lampBrightness = length(sunColor);
        // Altitude > ~3 degrees (0.2) AND Dim Light (< 2.0) = Moon
        bool isMoon = (sunDir.y > 0.2) && (lampBrightness < 2.0);
        
        if (isMoon) {
            sunColor = float3(0.0, 0.0, 0.0);
            // Remove Moon Light
        }

        float3 baseAmbColor = CB0.AmbientColor.xyz * 5.0;
        
        // --- SUNSET & NIGHT COLOR GRADING ---
        // Only apply if it is NOT the moon (Moon is forced black already)
        if (!isMoon) {
            float sunH = sunDir.y;
            // 1. Direct Sun Tint (White -> Gold -> Orange/Red)
            float3 dayTint = float3(1.0, 1.0, 1.0);
            float3 goldTint = float3(1.0, 0.8, 0.5);
            float3 redTint = float3(1.0, 0.4, 0.1);

            float3 currentTint = dayTint;
            if (sunH < 0.3) {
                // Interpolate Day -> Gold -> Red
                float t = smoothstep(0.0, 0.3, sunH);
                // Simple approximation: Below 0.15 is Red->Gold, Above is Gold->White
                if (sunH < 0.15) {
                    currentTint = lerp(redTint, goldTint, smoothstep(-0.1, 0.15, sunH));
                } else {
                    currentTint = lerp(goldTint, dayTint, smoothstep(0.15, 0.3, sunH));
                }

                // Dim the sun as it hits horizon so it doesn't stay super bright
                float extinction = smoothstep(-0.1, 0.2, sunH);
                sunColor *= currentTint * extinction;
            }

            // 2. Ambient Tint (Game Ambient -> Reddish -> Dark Blue)
            // Ambient usually stays brighter longer than direct sun
            float3 nightAmb = float3(0.10, 0.13, 0.2); // Deep Blue Night
            float3 sunsetAmb = float3(0.5, 0.3, 0.2);   // Reddish/Purple Dusk

            if (sunH < 0.2) {
                float tAmb = smoothstep(-0.05, 0.2, sunH);
                // Blend from Night(Blue) -> Sunset(Red) -> Day(Original)
                float3 horizonAmb = lerp(nightAmb, sunsetAmb, smoothstep(-0.05, 0.1, sunH));
                baseAmbColor = lerp(horizonAmb, baseAmbColor, tAmb);
            }
            if (sunH < -0.2) {
                sunDir = -sunDir;
                //sunColor = lerp(float3(0.2, 0.2, 0.2), float3(0, 0, 0), smoothstep(-0.4, -0.2, sunH));
            }
        } else {
            baseAmbColor = float3(0.10, 0.13, 0.2) * 1.2;
            //sunColor = float3(0.2, 0.2, 0.2);
        }

        float cosTheta = dot(rayDir, sunDir);
        float phaseVal = PhaseDualLobe(cosTheta, 0.8, -0.3, 0.7);
        float accdense = 0;
        [loop]
        for (int i = 0; i < steps; i++)
        {
            tcul = t;
            if (transmittance < 0.001) break;
            if (t > tFar || t > maxDist) break;
            // Depth Occlusion
           float radialSceneDepth = sceneDepth / viewCosTheta;

		if (t > radialSceneDepth) {
 		   break; 
		}

            float3 currentPos = camPos + rayDir * t;
            // Pass the windUV offset into the density function
            float rawDensity = GetDensity2(currentPos, cloudBottom, cloudThickness, noiseScale, windUV);
            float threshold = 1.0 - coverage;
            float density = smoothstep(threshold, threshold + 0.15, rawDensity);
            density *= (CB5.CoverDensityQuality.y > 0.0 ? CB5.CoverDensityQuality.y : 0.4) * 10.0;
            if (density > 0.01)
            {
                // CAPTURE DEPTH on first hit
                if (!depthCaptured) {
                    outputLinearDepth = t * viewCosTheta;
                    depthCaptured = true;
                }

                float lightTransmittance = 1.0;
                float3 lightPos = currentPos;
                float shadowStep = marchStep * 0.5;
                
                [unroll]
                for (int j = 0; j < 13; j++) {
                    lightPos += sunDir * shadowStep;
                    // Apply windUV to shadow lookup as well
                    float ld = GetDensity2(lightPos, cloudBottom, cloudThickness, noiseScale, windUV);
                    float lDens = smoothstep(threshold, threshold + 0.15, ld) * 4.0;
                    lightTransmittance *= exp(-lDens * 0.5);
                    shadowStep *= 1.5;
                }

                float powder = 1.0 - exp(-density * 4.0);
                float heightRatio = saturate((currentPos.y - cloudBottom) / cloudThickness);
                float3 ambient = baseAmbColor * (0.2 + 0.8 * heightRatio);
                float3 direct = sunColor * lightTransmittance * powder * phaseVal * 0.5;
                float3 totalLight = direct + ambient;
		float4 sampledSkyColor = SkyColor.Sample(CloudsSampler_s, screenUV*1);
                float3 cloudAlbedo = lerp(totalLight * cloudColor.xyz,sampledSkyColor.xyz,t/400000);

                float stepDensity = density * marchStep * 0.01;
		accdense += stepDensity;
                float stepTransmittance = exp(-stepDensity);

                accumulatedColor += cloudAlbedo * (transmittance - transmittance * stepTransmittance);
                transmittance *= stepTransmittance;
            }

            t += marchStep;
            marchStep *= 1.01;
        }

        finalAlpha = 1-transmittance;
        finalColor = accumulatedColor;//accumulatedColor;
    }

    if (finalAlpha < 0.001) {
        //discard;
    }

    // --- FIX START: Horizon Color Simulation & Distance Fog ---

    // 1. Define Horizon Colors to match your Sky Shader
    // Adjust these 3 values to perfectly match your specific Sky Shader looks
    float3 horzNight  = float3(0.02, 0.04, 0.10); // Dark Blue/Black
    float3 horzSunset = float3(0.80, 0.50, 0.20)/1.2; // Bright Orange
    float3 horzDay    = float3(0.70, 0.85, 1.00); // Pale/White-ish Blue

    // 2. Blend Horizon Color based on Sun Height
    float3 targetFogColor;
    float sunH = sunDir.y;

    if (sunH < 0.0) {
        // Blend Night -> Sunrise
        float t = smoothstep(-0.2, 0.0, sunH);
        targetFogColor = lerp(horzNight, horzSunset, t);
    } else {
        // Blend Sunrise -> Day
        float t = smoothstep(0.0, 0.2, sunH);
        targetFogColor = lerp(horzSunset, horzDay, t);
    }

    // 3. Recover Raw Cloud Color
    float3 rawCloudColor = finalColor / max(finalAlpha, 0.001);

    // 4. Calculate Fog Factor (Distance based)
    // Adjust '300000.0' to change how far the fog starts
    float fogFactor = saturate(tcul / 400000); 
    //fogFactor = pow(fogFactor, 1.5); // Exponential fog looks more natural

    // 5. Apply Fog to Color ONLY (Alpha stays intact)
    //if (Bob > 0.0) { rawCloudColor = float3(1, 0, 0); }
    float4 sampledSkyColor = SkyColor.Sample(CloudsSampler_s, screenUV*1);
    o0.xyz =rawCloudColor;//lerp(rawCloudColor, sampledSkyColor.xyz ,fogFactor);
    o0.w = finalAlpha; // Keep alpha based on cloud density, NOT distance

    // --- FIX END ---

    // Convert Linear Depth back to Buffer Depth
    oDepth = DEPTH_CONTROL / (outputLinearDepth + 0.000001);
    //o0 = float4(min((1/oDepth)/5000,0.8),min((1/oDepth)/5000,0.8),min((1/oDepth)/5000,0.8),1.0);
}