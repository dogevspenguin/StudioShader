// ---- Created with 3Dmigoto v1.3.16 ----
// Custom Atmosphere Shader - Space Flight & Multiple Scattering Emulation

cbuffer CB0 : register(b0)
{
  struct
  {
    row_major float4x4 ViewProjection[2];
    float4 ViewRight;
    float4 ViewUp;
    float4 ViewDir;
    float3 CameraPosition[2]; // Used for Altitude
    float3 AmbientColor;
    float4 SkyAmbient;
    float3 Lamp0Color;
    float3 Lamp0Dir;
    float3 Lamp1Color;
    float4 FogParams;
    float4 FogColor_GlobalForceFieldTime;
    float4 Exposure_DoFDistance;
    float4 LightConfig0;
    float4 LightConfig1;
    float4 LightConfig2;
    float4 LightConfig3;
    float4 ShadowMatrix0;
    float4 ShadowMatrix1;
    float4 ShadowMatrix2;
    float4 RefractionBias_FadeDistance_GlowFactor_Free;
    float4 TextureData_ShadowInfo;
    float4 SkyGradientTop_EnvDiffuse;
    float4 SkyGradientBottom_EnvSpec;
    float4 AmbientColorNoIBL_CubeBlend;
    float4 SkyAmbientNoIBL;
    float4 AmbientCube[12];
    float4 CascadeSphere0;
    float4 CascadeSphere1;
    float4 CascadeSphere2;
    float4 CascadeSphere3;
    float2 invViewportWH;
    float2 viewportScale;
    float debugAuthLodMode;
    float padding;
    float hqDist;
    float localLightDist;
    float sunDist;
    float hybridLerpSlope;
    float evsmPosExp;
    float evsmNegExp;
    float globalShadow;
    float shadowBias;
    float packedAlphaRef;
    float debugFlags;
    row_major float4x4 FroxelTransform;
    float4 SkyboxRotation0;
    float4 SkyboxRotation1;
    float4 SkyboxRotation2;
  } CB0 : packoffset(c0);
}

cbuffer CB4 : register(b4)
{
  struct
  {
    float4 FoV;
    float2 shearOffset;
    float2 pad;
  } CB4 : packoffset(c0);
}

SamplerState DiffuseMapSampler_s : register(s0);
Texture2D<float4> DiffuseMapTexture : register(t0);

// --------------------------------------------------------------------------
// TUNED CONSTANTS (Visual Correction)
// --------------------------------------------------------------------------
static const float PI = 3.14159265359;
static const float R_PLANET = 6360000.0;
static const float R_ATM = 6420000.0;     
static const float H_RAYLEIGH = 8000.0;   
static const float H_MIE = 1200.0;

// VISUAL FIX: Decoupled Coefficients
// "Scattering" = How much light turns blue. (Standard Earth values)
static const float3 BETA_R_SCAT = float3(5.8e-6, 1.35e-5, 3.31e-5); 

// "Extinction" = How much light is blocked. 
// We multiply by 0.6 to fake "Multiple Scattering". 
// This lets blue light pass through the horizon, turning it White/Blue instead of Yellow.
static const float3 BETA_R_EXT = float3(5.8e-6, 1.35e-5, 3.31e-5) * 0.6; 

static const float3 BETA_M_SCAT = float3(2.0e-6, 2.0e-6, 2.0e-6) * 1.0; 
static const float3 BETA_M_EXT  = float3(2.0e-6, 2.0e-6, 2.0e-6) * 1.0;

// --------------------------------------------------------------------------
// HELPER FUNCTIONS
// --------------------------------------------------------------------------

float2 ResolveSphereIntersection(float3 rayOrigin, float3 rayDir, float sphereRadius) {
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(rayDir, rayOrigin);
    float c = dot(rayOrigin, rayOrigin) - (sphereRadius * sphereRadius);
    float d = b * b - 4.0 * a * c;

    if (d < 0.0) return float2(-1.0, -1.0);
    
    float sqrtD = sqrt(d);
    return float2((-b - sqrtD) / (2.0 * a), (-b + sqrtD) / (2.0 * a));
}

float PhaseRayleigh(float cosTheta) {
    return (3.0 / (16.0 * PI)) * (1.0 + cosTheta * cosTheta);
}

// Mie Phase (Gedzelman)
float PhaseMie(float cosTheta) {
    float a = 1.5;
    float gamma = acos(clamp(cosTheta, -1.0, 1.0));
    float num = 2.0 * (1.0 + a * a);
    float den = 2.0 * PI * (1.0 + exp(-a * PI));
    float term1 = (1.0 - exp(-a * PI * 0.5)) * exp(-a * gamma);
    float term2 = exp(-a * PI * 0.5) * exp(-a * (PI - gamma));
    return (num / den) * (term1 + term2);
}

float2 GetSunOpticalDepth(float3 p, float3 sunDir) {
    float2 intersect = ResolveSphereIntersection(p, sunDir, R_ATM);
    float distToSpace = intersect.y;
    
    if (distToSpace < 0.0) return float2(0,0);

    int steps = 4;
    float stepSize = distToSpace / float(steps);
    float odR = 0.0;
    float odM = 0.0;

    for(int i = 0; i < steps; i++) {
        float3 curr = p + sunDir * (float(i) * stepSize + 0.5 * stepSize);
        float h = max(0.0, length(curr) - R_PLANET);
        odR += exp(-h / H_RAYLEIGH) * stepSize;
        odM += exp(-h / H_MIE) * stepSize;
    }
    return float2(odR, odM);
}

// --------------------------------------------------------------------------
// MAIN SHADER
// --------------------------------------------------------------------------
void main(
  float4 v0 : SV_Position0,
  float2 v1 : TEXCOORD0,
  float4 v2 : COLOR0,
  out float4 o0 : SV_Target0)
{
    // 1. RAY RECONSTRUCTION
    float4 r0;
    float3 r1;
    r0.xy = float2(0.5, 0.5) * v0.xy;
    r0.xy = r0.xy / CB0.viewportScale.xy;
    r0.zw = r0.xy * CB4.FoV.xy + float2(-1, -1);
    r0.zw = CB4.FoV.zw * r0.zw + CB4.shearOffset.xy;
    r1.xyz = CB0.ViewUp.xyz * r0.www;
    r1.xyz = r0.zzz * CB0.ViewRight.xyz + -r1.xyz;
    r1.xyz = -CB0.ViewDir.xyz + r1.xyz;
    float3 viewDir = normalize(r1);

    // 2. DYNAMIC ALTITUDE & LIGHT
    float3 sunDir = -normalize(CB0.Lamp0Dir.xyz); 
    float camAltitude = max(10.0, CB0.CameraPosition[0].y); 
    float3 startPos = float3(0, R_PLANET + camAltitude, 0);

    // 3. INTERSECTION & SPACE LOGIC
    float2 atmHit = ResolveSphereIntersection(startPos, viewDir, R_ATM);
    float2 planetHit = ResolveSphereIntersection(startPos, viewDir, R_PLANET);

    float marchStart = 0.0;
    float marchEnd = atmHit.y;

    // Space Check: Are we above the atmosphere?
    if (camAltitude > (R_ATM - R_PLANET)) {
        // Looking into deep space?
        if (atmHit.x < 0.0 && atmHit.y < 0.0) {
             float cosTheta = dot(viewDir, sunDir);
             float sunDisk = smoothstep(0.9998, 0.99995, cosTheta);
             o0 = float4(float3(20,20,20) * sunDisk, 1.0);
             return; 
        }
        // Looking at atmosphere from space
        marchStart = atmHit.x;
        marchEnd = atmHit.y;
    }

    if (planetHit.x > 0.0) {
        marchEnd = min(marchEnd, planetHit.x);
    }
    
    if (marchEnd < marchStart) {
        o0 = float4(0,0,0,1);
        return;
    }

    // 4. RAY MARCHING
    int numSteps = 16;
    float stepSize = (marchEnd - marchStart) / float(numSteps);
    
    float3 totalRayleigh = float3(0,0,0);
    float3 totalMie = float3(0,0,0);
    float odR_View = 0.0;
    float odM_View = 0.0;
    float cosTheta = dot(viewDir, sunDir);

    for (int i = 0; i < numSteps; i++) {
        float dist = marchStart + float(i) * stepSize + 0.5 * stepSize;
        float3 p = startPos + viewDir * dist;
        float h = max(0.0, length(p) - R_PLANET);

        // Density
        float hr = exp(-h / H_RAYLEIGH) * stepSize;
        float hm = exp(-h / H_MIE) * stepSize;
        
        odR_View += hr;
        odM_View += hm;

        // Light Path
        float2 odSun = GetSunOpticalDepth(p, sunDir);
        
        // VISUAL FIX: Use Reduced Extinction Coefficients
        float3 tau = BETA_R_EXT * (odR_View + odSun.x) + 
                     BETA_M_EXT * 1.1 * (odM_View + odSun.y);
                     
        float3 attn = exp(-tau);

        totalRayleigh += hr * attn;
        totalMie += hm * attn;
    }

    // 5. COMPOSITION
    float3 sunIntensity = float3(20.0, 20.0, 20.0);
    float pR = PhaseRayleigh(cosTheta);
    float pM = PhaseMie(cosTheta);

    // VISUAL FIX: Use Full Scattering Coefficients for color brightness
    float3 atmosphere = sunIntensity * (totalRayleigh * BETA_R_SCAT * pR + totalMie * BETA_M_SCAT * pM);

    // 6. SUN & EXTINCTION
    float cosSun = dot(viewDir, sunDir);
    float sunDisk = smoothstep(0.9998, 0.99995, cosSun);
    
    // Accurate sun filtering from Camera position
    float2 camToSunOD = GetSunOpticalDepth(startPos, sunDir);
    float3 sunExtinction = exp(-(BETA_R_EXT * camToSunOD.x + BETA_M_EXT * 1.1 * camToSunOD.y));
    float3 sunColor = sunIntensity * sunDisk * sunExtinction * 10.0;

    float3 finalColor = atmosphere + sunColor;

    // 7. TONE MAPPING
    float exposure = max(0.2, CB0.Exposure_DoFDistance.y); 
    
    // Reinhard
    float3 col = finalColor * exposure;
    col = col / (1.0 + col); 
    
    o0.xyz = pow(saturate(col), 1.0/2.2); 
    o0.w = 1.0;
}